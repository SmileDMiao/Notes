### 树
---
1. 树是由 n（n≥0）个结点组成的有限集合。
2. 当 n = 0 时，称为空树；
3. 当 n > 0 时，有一个特殊的节点称为根结点（root），它没有前驱结点；其它结点分为 m 棵互不相交的子树。

![IMAGE](resources/5394F77E4004D40872C79C1C5C8C4A7D.jpg =711x299)
**结点**
1. 父结点：若一个结点含有孩子结点，则这个结点称为其孩子结点的父结点；如上图所示，B、C、D 的父结点都是 A；
2. 孩子结点：一个结点含有的子树的根结点称为该结点的孩子结点；定义还是比较拗口，还是直接看图吧，B 的孩子结点为 E、F；
3. 兄弟节点：具有相同父结点的结点互称为兄弟结点；如上图所示，B、C、D 具有相同的父结点 A，所以 B、C、D 为兄弟结点；

**结点的度**
一个结点拥有子树的个数称为该结点的度；如上图所示，A 结点拥有 B、C、D 三棵子树，所以 A 结点的度为 3；

**树的度**
一棵树中，最大的结点度称为树的度；如上图所示，最大的结点度为 3，所以树的度为 3；

**结点层次**
从根开始算起，根为第 1 层，根的子节点为第 2 层，以此类推；如上图所示，E 结点层次为第 3 层；
树的深度或高度：树中结点的最大层次数；如上图所示，由于结点最大层次树为 3，所以树的深度或高度为 3；

### 二叉树
---
1. 二叉树（binary tree）是 n（n≥0）个结点组成的有限集合。
2. n = 0 时称为空二叉树；
3. n > 0 的二叉树由一个根结点和两棵互不相交的、分别称为左子树和右子树的子二叉树构成。
4. 当二叉树的每一层的结点数目都达到最大值，则称为满二叉树。
5. 完全二叉树相对满二叉树而言，节点数是任意的，从形式上去看，最后那一行可能是不完整的，可能右下角某个连续的部分缺失
6. 满二叉树一定是完全二叉树，而完全二叉树不一定是满二叉树，区别就在最后一层上。

### 二叉排序树
---
由于二叉排序树能够提供快速查找功能，所以二叉排序树又称为二叉查找树
二叉排序树可以是一棵空树，或者是具有如下性质的二叉树：
1. 每个结点都有一个作为查找依据的关键字，而且所有结点的关键字互不相同；
2. 结点，左子树元素均小于该结点，右子树元素均大于该结点；
3. 左、右子树也是二叉排序树。


### 平衡二叉树
---
二叉排序树的查找效率与二叉树的高度有关，高度越低，查找效率越高。因此，提高二叉排序树查找效率的办法是尽量降低二叉排序树的高度，于是就有了平衡二叉树。
平衡二叉树的主要的特点
1. 它的左子树与右子树的高度之差绝对值不超过 1
2. 它的左子树和右子树都是平衡二叉树。
3. 另外，结点的平衡因子 = 左子树的高度 – 右子树的高度，在平衡二叉树中任何一个结点的平衡因子只能是 -1、0 或 1.


在面对新结点加入时，可能会使平衡二叉树不平衡，那么就需要通过旋转来达到平衡。但是，无论怎么旋转，都无外乎 LL、RR、LR 和 RL 四种情形
![IMAGE](resources/8A15B7190096BB6406DFFAD8B167C433.jpg =760x253)
![IMAGE](resources/ACFBBBBEB2F454F501D36D89292D999B.jpg =687x263)
![IMAGE](resources/D30811B6E46D1E8AB0DF93396E2929F9.jpg =710x477)
![IMAGE](resources/2ECCDF7E9A11EA37DAF1E4E2EC387864.jpg =664x670)

存储结构:
采用两条链分别连接左、右孩子，每个结点有三个域：data 存储数据元素，left、right 分别指向左、右孩子结点
![IMAGE](resources/3DE106F9C6D9574D29AB9EAF22F19442.jpg =736x323)
采用二叉链表存储二叉树，只保存了结点到孩子结点的单向关系，而没有存储结点到父结点的关系，所以要想获得父结点，需要从根结点开始在二叉树中进行查找，那么花费的时间会较多
![IMAGE](resources/FE71C7EF02E92A0DDD2E046006A79CE7.jpg =715x400)


### 红黑树
---
红黑树是一种自平衡二叉查找树
红黑树是每个节点都带有颜色属性的二叉查找树，颜色或红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:
1. 节点是红色或黑色。
2. 根节点是黑色。
3. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
4. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。


### B-Tree
---
B树(英语: B-tree)是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一个**一般化的二叉查找树（binary search tree）**一个节点可以拥有2个以上的子节点。与自平衡二叉查找树不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。B树减少定位记录时所经历的中间过程，从而加快存取速度。B树这种数据结构可以用来描述外部存储。这种数据结构常被应用在数据库和文件系统的实现上。

在B树中，内部(非叶子)节点可以拥有可变数量的子节点(数量范围预先定义好)。当数据被插入或从一个节点中移除，它的子节点数量发生变化。为了维持在预先设定的数量范围内，内部节点可能会被合并或者分离。因为子节点数量有一定的允许范围，所以B树不需要像其他自平衡查找树那样频繁地重新保持平衡，但是由于节点没有被完全填充，可能浪费了一些空间。子节点数量的上界和下界依特定的实现而设置。

B树中每一个内部节点会包含一定数量的键，键将节点的子树分开。
为了描述B-Tree，首先定义一条数据记录为一个二元组[key,data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。那么B-Tree是满足下列条件的数据结构:

d=2的B-Tree
![IMAGE](resources/63A00F6A0684909177FCD0FAE027C0D6.jpg =586x154)

![IMAGE](resources/17A9C0D06D0E24C11D51278805EEBEF9.jpg =405x115)
1. d为大于1的一个正整数，称为B-Tree的度。
2. h为一个正整数，称为B-Tree的高度。
3. 每个非叶子节点由n-1个key和n个指针组成，其中d<=n<=2d。
4. 每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。
5. 所有叶节点具有相同的深度，等于树高h。
6. key和指针互相间隔，节点两端是指针。
7. **一个节点中的key从左到右非递减排列。？**
8. 所有节点组成树结构。
9. 每个指针要么为null，要么指向另外一个节点。
10. 如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于 v(key1)，其中 v(key1)为node的第一个key的值。
11. 如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于 v(keym)，其中 v(keym)为node的最后一个key的值。
12. 如果某个指针在节点node的左右相邻key分别是 keyi和 keyi+1且不为null，则其指向节点的所有key小于 v(keyi+1)且大于 v(keyi)。

由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。
B树使用的一些思想:
1. 保持键值有序，以顺序遍历
2. 使用层次化的索引来最小化磁盘读取
3. 使用不完全填充的块来加速插入和删除
4. 通过优雅的遍历算法来保持索引平衡
5. B树通过保证内部节点至少半满来最小化空间浪费。一棵B树可以处理任意数目的插入和删除。


### B+Tree
---
与B-Tree相比，B+Tree有以下不同点:
1. 每个节点的指针上限为2d而不是2d+1。
2. 内节点不存储data，只存储key；叶子节点不存储指针。

![IMAGE](resources/10E6AF1A0D4144EF08A9F335AD08A958.jpg =615x229)
一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。
在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能