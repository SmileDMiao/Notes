## 数据库状态字段索引
---
1. 如果where 只查索引字段，查询会使用索引，且效率提升明显！
2. 如果where 查询索引字段+非索引字段，如果查询索引枚举值较少的这部分数据，效率有提升；
3. 如果where 查询索引字段+非索引字段，如果查询枚举值相差不大或者查询较多的这部分数据时，索引大大降低了查询效率！可怕的是，比全表索引效率还要低的多！

## Mysql为什么使用B+Tree做索引
---
为什么不是二叉树，为什么不是平衡二叉树，为什么不是B树，而偏偏是B+树呢？

*为什么不是一般二叉树？*
如果二叉树特殊化为一个链表，相当于全表扫描。平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。

*为什么不是平衡二叉树呢？*
如果树这种数据结构作为索引，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块，但是平衡二叉树可是每个节点只存储一个键值和数据的，如果是B树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就降下来啦，查询效率就快啦。

*那为什么不是B树而是B+树呢？*
1. B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。innodb中页的默认大小是16KB，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。
2. B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。

## 为什么MongoDB使用BTree
---
+ B树恰好 key 和 data 域聚合在一起。
+ MongoDB 作为面向文档的数据库，与数据之间的关系相比，它更看重以文档为中心的组织方式，所以选择了查询单个文档性能较好的 B 树，这个选择对遍历数据的查询也可以保证可以接受的时延。
+ 所有节点都有一个数据字段。只要找到指定的索引，就可以对其进行访问。毫无疑问，单个查询MongoDB平均查询速度比Mysql快。

## 什么是幻读，脏读，不可重复读呢？
---
1. 事务A、B交替执行，事务A被事务B干扰到了，因为事务A读取到事务B未提交的数据,这就是脏读
2. 在一个事务范围内，两个相同的查询，读取同一条记录，却返回了不同的数据，这就是不可重复读。
3. 事务A查询一个范围的结果集，另一个并发事务B往这个范围中插入/删除了数据，并静悄悄地提交，然后事务A再次查询相同的范围，两次读取得到的结果集不一样了，这就是幻读。

## MySQL事务得四大特性以及实现原理(ACID)
---
**ACID**
+ 原子性-A=Atomicity: 事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。
+ 一致性-C=Consistency: 指在事务开始之前和事务结束以后，数据不会被破坏，假如A账户给B账户转10块钱，不管成功与否，A和B的总金额是不变的。
+ 隔离性-I=Isolation: 多个事务并发访问时，事务之间是相互隔离的，即一个事务不影响其它事务运行效果。简言之，就是事务之间是进水不犯河水的。
+ 持久性-D=Durability: 表示事务完成以后，该事务对数据库所作的操作更改，将持久地保存在数据库之中。

**实现**
+ 原子性: 是使用 undo log来实现的，如果事务执行过程中出错或者用户执行了rollback，系统通过undo log日志返回事务开始的状态。
+ 持久性: 使用 redo log来实现，只要redo log日志持久化了，当系统崩溃，即可通过redo log把数据恢复。
+ 隔离性: 通过锁以及MVCC,使事务相互隔离开。
+ 一致性: 通过回滚、恢复，以及并发情况下的隔离性，从而实现一致性。

## MySQL事物隔离级别
---
Innodb使用的是哪种隔离级别呢?
InnoDB默认使用的是可重复读隔离级别(REPEATABLE READ)


1. 未提交读(READ UNCOMMITTED)
这个隔离级别下,其他事务可以看到本事务没有提交的部分修改.因此会造成脏读的问题(读取到了其他事务未提交的部分,而之后该事务进行了回滚).这个级别的性能没有足够大的优势,但是又有很多的问题,因此很少使用.

2. 已提交读(READ COMMITTED)
其他事务只能读取到本事务已经提交的部分.这个隔离级别有不可重复读的问题,在同一个事务内的两次读取,拿到的结果竟然不一样,因为另外一个事务对数据进行了修改.

3. REPEATABLE READ(可重复读)
可重复读隔离级别解决了上面不可重复读的问题(看名字也知道),但是仍然有一个新问题,就是 幻读,当你读取 `id> 10` 的数据行时,对涉及到的所有行加上了读锁,此时例外一个事务新插入了一条id=11的数据,因为是新插入的,所以不会触发上面的锁的排斥,那么进行本事务进行下一次的查询时会发现有一条id=11的数据,而上次的查询操作并没有获取到,再进行插入就会有主键冲突的问题.

4. SERIALIZABLE(可串行化)
这是最高的隔离级别,可以解决上面提到的所有问题,因为他强制将所以的操作串行执行,这会导致并发性能极速下降,因此也不是很常用.

## 主键使用自增ID还是UUID?
---
推荐使用自增ID,不要使用UUID. 因为在InnoDB存储引擎中,主键索引是作为聚簇索引存在的,也就是说,主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序),如果主键索引是自增ID,那么只需要不断向后排列即可,如果是UUID,由于到来的ID与原来的大小不确定,会造成非常多的数据插入,数据移动,然后导致产生很多的内存碎片,进而造成插入性能的下降. 总之,在数据量大一些的情况下,用自增主键性能会好一些.

## 三个范式
---
1. 第一范式: 每个列都不可以再拆分. 
2. 第二范式: 非主键列完全依赖于主键, 而不能是依赖于主键的一部分. 
3. 第三范式: 非主键列只依赖于主键,不依赖于其他非主键.
在设计数据库结构的时候,要尽量遵守三范式,如果不遵守,必须有足够的理由.比如性能. 事实上我们经常会为了性能而妥协数据库的设计.

## 列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？
---
它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。

##  MySQL支持哪些存储引擎?
---
> MySQL支持多种存储引擎,比如InnoDB,MyISAM,Memory,Archive等等.在大多数的情况下,直接选择使用InnoDB引擎都是最合适的,InnoDB也是MySQL的默认存储引擎.

1. InnoDB支持事物，而MyISAM不支持事物
2. InnoDB支持行级锁，而MyISAM支持表级锁
3. InnoDB支持MVCC, 而MyISAM不支持
4. InnoDB支持外键，而MyISAM不支持
5. InnoDB不支持全文索引，而MyISAM支持。


## MySQL中的varchar和char有什么区别.
---
> char是一个定长字段,假如申请了char(10)的空间,那么无论实际存储多少内容.该字段都占用10个字符,而varchar是变长的,也就是说申请的只是最大长度,占用的空间为实际字符长度+1,最后一个字符存储使用了多长的空间.

1.CHAR和VARCHAR类型在存储和检索方面有所不同
2.CHAR列长度固定为创建表时声明的长度，长度值范围是1到255
当CHAR值被存储时，它们被用空格填充到特定长度，检索CHAR值时需删除尾随空格。

## varchar(10)和int(10)代表什么含义?
---
1. varchar的10代表了申请的空间长度,也是可以存储的数据的最大长度
2. int的10只是代表了展示的长度,不足10位以0填充.也就是说,int(1)和int(10)所能存储的数字大小以及占用的空间都是相同的,只是在展示时按照长度展示.

## 查询过程
1. 语法分析: 检查语法
2. 语义检查
3. 查询重写: 优化器进行查询优化的开始阶段
4. 优化访问计划: 根据查询图模型提供的信息，优化器会生成许多能够满足查询请求的访问计划（执行方案方案），然后优化器综合系统编目表中关于表，索引，列和函数等等的统计信息，估计每种访问计划的执行成本，并选择具有最小成本的方案作为最终的访问计划（Acess Plan）
5. 生成可执行代码
6. 执行访问计划（Execute Plan）
7. 缓存管理