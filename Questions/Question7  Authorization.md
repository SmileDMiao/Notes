## Oauth2.0
---
#### 授权码authorization code
> 这种方式是最常用的流程，安全性也最高，它适用于那些有后端的Web应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。

1. A网站提供一个链接, 用户点击跳转到B网站, 授权用户数据给A网站使用
2. 用户跳转后, B 网站会要求用户登录，然后询问是否同意给予 A 网站授权。这时 B 网站就会跳回redirect_uri参数指定的网址。跳转时，会传回一个授权码
3. A网站拿到授权码以后，就可以在后端，向 B 网站请求令牌。
4. B网站收到请求以后，就会颁发令牌。具体做法是向redirect_uri指定的网址，发送一段 JSON 数据


#### 隐藏式implicit
1. A 网站提供一个链接，要求用户跳转到 B 网站，授权用户数据给 A 网站使用。
2. 用户跳转到 B 网站，登录后同意给予 A 网站授权。这时，B 网站就会跳回redirect_uri参数指定的跳转网址，并且把令牌作为 URL 参数，传给 A 网站


### 密码式password
1. A 网站要求用户提供 B 网站的用户名和密码。拿到以后，A 就直接向 B 请求令牌。
2. B 网站验证身份通过后，直接给出令牌。注意，这时不需要跳转，而是把令牌放在 JSON 数据里面，作为 HTTP 回应，A 因此拿到令牌。

### 凭证式client credentials
> 这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。

1. A 应用在命令行向 B 发出请求。
2. B 网站验证通过以后，直接返回令牌。


## SAML2.0
---
1. 还未登陆的用户打开浏览器访问你的网站(sp), 网站提供服务但是并不负责用户认证。
2. 于是 SP 向 IDP(IdentityProvider) 发送了一个 SAML 认证请求，同时 SP 将 用户浏览器 重定向到 IDP。
3. IDP 在验证完来自 SP 的 请求无误 之后，在浏览器中呈现 登陆表单 让用户填写 用户名 和 密码 进行登陆。
4. 一旦用户登陆成功， IDP 会生成一个包含 用户信息（用户名 或者 密码）的 SAML token（SAML token 又称为 SAML Assertion，本质上是 XML 节点）。IDP 向 SP 返回 token，并且将 用户重定向 到 SP (token 的返回是在 重定向步骤 中实现的，下面会详细说明)。
5. SP 对拿到的 token 进行验证，并从中解析出 用户信息，例如 用户是谁 以及 用户的权限 有哪些。此时就能够根据这些信息允许用户访问我们网站的内容。