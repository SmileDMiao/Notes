## 常见的 GC 实现方式有哪些？Go 语言的 GC 使用的是什么？
---
所有的 GC 算法其存在形式可以归结为追踪（Tracing）和引用计数（Reference Counting）这两种形式的混合运用。
1. **追踪式 GC**
从根对象出发，根据对象之间的引用信息，一步步推进直到扫描完毕整个堆并确定需要保留的对象，从而回收所有可回收的对象。Go、 Java、V8 对 JavaScript 的实现等均为追踪式 GC。
2. **引用计数式 GC**
每个对象自身包含一个被引用的计数器，当计数器归零时自动得到回收。因为此方法缺陷较多，在追求高性能时通常不被应用。Python、Objective-C 等均为引用计数式 GC。

目前比较常见的 **追踪式** GC 实现方式包括:
1. 标记清扫: 从根对象出发，将确定存活的对象进行标记，并清扫可以回收的对象。
2. 标记整理: 为了解决内存碎片问题而提出，在标记过程中，将对象尽可能整理到一块连续的内存上。
3. 增量式: 将标记与清扫的过程分批执行，每次执行很小的部分，从而增量的推进垃圾回收，达到近似实时、几乎无停顿的目的。
4. 增量整理: 在增量式的基础上，增加对对象的整理过程。
5. 分代式: 将对象根据存活时间的长短进行分类，存活时间小于某个值的为年轻代，存活时间大于某个值的为老年代，永远不会参与回收的对象为永久代。并根据分代假设（如果一个对象存活时间不长则倾向于被回收，如果一个对象已经存活很长时间则倾向于存活更长时间）对对象进行回收。

Go 的 GC 目前使用的是无分代(对象没有代际之分)，不整理(回收过程中不对对象进行移动与整理)，并发(与用户代码并发执行)的三色标记清扫算法。
1. 对象整理的优势是解决内存碎片问题以及 "允许" 使用顺序内存分配器。Go 运行时的分配算法基于 tcmalloc，基本上没有碎片问题。 并且顺序内存分配器在多线程的场景下并不适用。Go 使用的是基于 tcmalloc 的现代内存分配算法，对对象进行整理不会带来实质性的性能提升。
2. 分代 GC 依赖分代假设，即 GC 将主要的回收目标放在新创建的对象上(存活时间短，更倾向于被回收)，而非频繁检查所有对象。但 Go 的编译器会通过 逃逸分析 将大部分新生对象存储在栈上（栈直接被回收），只有那些需要长期存在的对象才会被分配到需要进行垃圾回收的堆中。也就是说，分代 GC 回收的那些存活时间短的对象在 Go 中是直接被分配到栈上，当 goroutine 死亡后栈也会被直接回收，不需要 GC 的参与，进而分代假设并没有带来直接优势。并且 Go 的垃圾回收器与用户代码并发执行，使得 STW 的时间与对象的代际，对象的 size 没有关系。Go 团队更关注于如何更好地让 GC 与用户代码并发执行(使用适当的 CPU 来执行垃圾回收)，而非减少停顿时间这一单一目标上。

## 根对象到底是什么？
---
根对象在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象，包括:
1. 全局变量: 程序在编译期就能确定的那些存在于程序整个生命周期的变量。
2. 执行栈: 每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针。
3. 寄存器: 寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。

## 标记清除(mark and sweep)
---
**过程**
1. STW
2. 找到可达对象 不可达对象
3. 标记可达对象
4. 清除未标记对象
5. 停止STW

**缺点**
1. 程序暂停, 影响性能
2. 标记需要扫描整个Heap
3. 清除会产生Heap碎片
4. 可以尝试将第5步和第四部交换(略微提升)

## 三色标记
---
> 理解三色标记法的关键是理解 **对象的三色抽象** 以及 **波面(wavefront)推进** 这两个概念。三色抽象只是一种描述追踪式回收器的方法，在实践中并没有实际含义，它的重要作用在于从逻辑上严密推导标记清理这种垃圾回收方法的正确性。也就是说，当我们谈及三色标记法时，通常指标记清扫的垃圾回收

*从垃圾回收器的视角来看，三色抽象规定了三种不同类型的对象，并用不同的颜色相称*
**白色**: `(可能死亡)未被回收器访问到的对象。在回收开始阶段，所有对象均为白色，当回收结束后，白色对象均不可达。`
**灰色**: `(波面)已被回收器访问到的对象，但回收器需要对其中的一个或多个指针进行扫描，因为他们可能还指向白色对象。`
**黑色**: `(确定存活)已被回收器访问到的对象，其中所有字段都已被扫描，黑色对象中任何一个指针都不可能直接指向白色对象。`

**标记过程**
1. 程序开始时将全部节点标记为白色
2. 从根节点遍历所有对象 **(往下一层)** 将遍历到的白色对象标记为灰色
3. 遍历灰色集合，将灰色引用的对象从白色标记为灰色，之后将灰色对象标记为黑色
4. 重复步骤3直到没有灰色节点
5. 回收白色标记的对象 

> 这样三种不变性所定义的回收过程其实是一个波面不断前进的过程，这个波面同时也是黑色对象和白色对象的边界，灰色对象就是这个波面。
当垃圾回收开始时，只有白色对象。随着标记过程开始进行时，灰色对象开始出现，这时候波面便开始扩大。当一个对象的所有子节点均完成扫描时，会被着色为黑色。当整个堆遍历完成时，只剩下黑色和白色对象，这时的黑色对象为可达对象，即存活; 而白色对象为不可达对象，即死亡; 这个过程可以视为以灰色对象为波面，将黑色对象和白色对象分离，使波面不断向前推进，直到所有可达的灰色对象都变为黑色对象为止的过程

### 三色标记的问题(不考虑STW)
*三色标记最不希望发生的事，也就是对象丢失的条件*
> 如果条件1和2同时满足的话就会出现对象丢失现象，但STW有明显的资源浪费，那么如何保证对象不丢失的情况下进可能提高GC效率减少STW时间?

1. 白色对象被黑色对象引用(白色被挂在黑色下面)
2. 灰色对象与它之间的可达关系的白色对象遭到破坏(灰色丢了白色对象)

### 强三色不变式与弱三色不变式
**破坏对象丢失的两个条件**
1. 强三色不变式: 强制性不允许黑色对象引用白色对象(破坏条件1: 白色对象被黑色对象引用)
2. 弱三色不变式: 黑色对象可以引用白色对象，白色对象存在其他灰色对象引用，或者可达这个白色对象的链路上游存在灰色对象(破坏条件2: 灰色对象与它之间的可达关系的白色对象遭到破坏)

## 屏障
---
> 额外的判断机制(hook) callback

1. 插入屏障: 对象被引用触发的机制
2. 删除屏障: 对象被删除时触发的机制

### 插入屏障
具体操作:
在A对象引用B对象的时候，B对象被标记为灰色(B挂在A下游，B必须为灰色)

满足: 
强三色不变式(不存在黑色对象引用白色对象的情况, 白色会变成灰色)

只有在堆上触发，栈上没有触发

不足: 
结束时需要STW来重新扫描栈（10-100ms）

### 删除屏障
具体操作:
被删除的对象，如果自身为灰色或者白色，那么被标记为灰色

满足:
弱三色不变式

不足: 
回收精度低，保护标记为灰色对象一轮，下次遍历的时候被删除

### 混合写屏障机制
具体操作:
1. GC开始时将栈上的全部对象扫描并标记为黑色(之后不再进行第二次重复扫描 无需STW)
2. GC期间, 任何再栈上创建的对象均为黑色 
3. 被删除的对象标记为灰色
4. 被添加的对象标记为灰色

## GC过程
1. Mark阶段该: 阶段又分为两个部分: 
  **Mark Prepare:** 初始化GC任务，包括开启写屏障(write barrier)和辅助GC(mutator assist)，统计root对象的任务数量等，这个过程需要STW。
  **GC Drains:** 扫描所有root对象，包括全局指针和goroutine(G)栈上的指针(扫描对应G栈时需停止该G)，将其加入标记队列(灰色队列)，并循环处理灰色队列的对象，直到灰色队列为空。该过程后台并行执行。
2. Mark Termination阶段: 该阶段主要是完成标记工作，重新扫描(re-scan)全局指针和栈。因为Mark和用户程序是并行的，所以在Mark过程中可能会有新的对象分配和指针赋值，这个时候就需要通过写屏障(write barrier)记录下来，re-scan 再检查一下，这个过程也是会STW的。
3. Sweep: 按照标记结果回收所有的白色对象，该过程后台并行执行。
4. Sweep Termination: 对未清扫的span进行清扫, 只有上一轮的GC的清扫工作完成才可以开始新一轮的GC。