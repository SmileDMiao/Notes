## Go语言的主要特征
---
1.自动立即回收
2.更丰富的内置类型
3.函数多返回值
4.错误处理
5.匿名函数和闭包
6.类型和接口
7.并发编程
8.反射
9.语言交互性

## go clean
---
移除当前源码包和关联源码包里面编译生成的文件
1. go build在当前目录下生成的与包名或者 Go 源码文件同名的可执行文件
2. go test 加入-c标记时在当前目录下生成的以包名加 .test 后缀为名的文件
3. go install 安装当前代码包时产生的结果文件
4. 目录下相应的归档文件。如果当前代码包中只包含一个命令源码文件，则结果文件指的就是在工作区 bin 目录下的可执行文件
5. 在编译 Go 或 C 源码文件时遗留在相应目录中的文件或目录

参数
+ -i: 清除关联的安装的包和可运行文件, 也就是通过go install安装的文件
+ -n: 把需要执行的清除命令打印出来, 但是不执行, 这样就可以很容易的知道底层是如何运行的
+ -r: 循环的清除在 import 中引入的包
+ -x: 打印出来执行的详细命令, 其实就是 -n 打印的执行版本
+ -cache: 删除所有go build命令的缓存
+ -testcache: 删除当前包所有的测试结果

## 值类型与引用类型
---
值类型:
基本数据类型: int float bool string 数组 struct

引用类型:
指针 slice map chan等都是引用类型


## 内置函数
---
+ append: 用来追加元素到数组 slice中, 返回修改后的数组 slice
+ close: 主要用来关闭channel
+ delete: 从map中删除key对应的value
+ panic: 触发异常
+ recover: 处理异常(在defer中才有效)
+ real: 返回complex的实部(complex real imag: 用于创建和操作复数)
+ imag: 返回complex的虚部
+ make: 分配内存，返回Type本身(只能应用于slice map channel)
+ new: 分配内存, 主要用来分配值类型, 比如 int struct, 返回指向Type的指针
+ cap: 返回某个类型的最大容量（只能用于切片和 map）
+ copy: 制和连接slice, 返回复制的数目
+ len: 求长度, 比如string array slice map channel
+ print&println: 底层打印函数，在部署环境中建议使用 fmt 包
    
## 内置接口error
---
```go
//只要实现了Error()函数，返回值为String的都实现了err接口
type error interface {
    Error()    String

}
```
    
## init函数
---
go语言中init函数用于包(package)的初始化
1. init函数是用于程序执行前做包的初始化的函数, 比如初始化包里的变量等
2. 每个包可以拥有多个init函数
3. 包的每个源文件也可以拥有多个init函数
4. 不同包的init函数按照包导入的依赖关系决定该初始化函数的执行顺序
5. init函数不能被其他函数调用, 而是在main函数执行之前, 自动被调用

init函数和main函数的异同
相同点: 两个函数在定义时不能有任何的参数和返回值，且Go程序自动调用
不同点: init可以应用于任意包中, 且可以重复定义多个。main函数只能用于main包中, 且只能定义一个

### 下划线 "_" 是特殊标识符,用来忽略结果。
---
import 下划线的作用: 当导入一个包时, 该包下的文件里所有init()函数都会被执行, 然而, 有些时候我们并不需要把整个包都导入进来, 仅仅是是希望它执行init()函数而已。引用该包仅仅是为了调用init()函数, 所以无法通过包名来调用包中的其他函数。

### iota
---
iota是go语言的常量计数器, 只能在常量的表达式中使用。
iota在const关键字出现时将被重置为0。const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)。使用iota能简化定义, 在定义枚举时很有用。

### package可见性规则
---
当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头, 如:Group1, 那么使用这种形式的标识符的对象就可以被外部包的代码所使用(像面向对象语言中的 public) 标识符如果以小写字母开头, 则对包外是不可见的, 但是他们在整个包的内部是可见并且可用的(像面向对象语言中的 private)。因此，在导入一个外部包后，能够且只能够访问该包中导出的对象。

### go race 检测
---
一般并发的bug 有两种: 死锁(block)和 竞争(race)

1. 死锁发生时，go run 会直接报错
2. race 发生时, 要加race 才会在运行时报warning, go run --race xxx.go

## make与new
---
new 和 make 是 Go 语言内建函数，用来分配内存:
1. new会为 T 类型的新值分配已置零的内存空间，并返回地址(指针)，即类型为 *T的值。返回一个指针，该指针指向新分配的类型为 T 的零值。适用于值类型，如数组，结构体等。
2. make返回初始化之后的 T 类型的值，这个值并不是 T 类型的零值，也不是指针 *T，是经过初始化之后的 T 的引用。make() 只适用于 slice、map 和 channel.

## struct比较
---
1. 如果结构体的所有成员变量都是可比较的，那么结构体就可比较
2. 如果结构体中存在不可比较的成员变量，那么结构体就不能比较
3. 结构体之间进行转换需要他们具备完全相同的成员(字段名、字段类型、字段个数)

## nil赋值
---
**nil 只能赋值给指针、chan、func、interface、map 或 slice 类型的变量。**

## 单引号 双引号 反引号
---
Golang的双引号和反引号都可用于表示一个常量字符串，不同在于：

1. 双引号用来创建可解析的字符串字面量(支持转义，但不能用来引用多行)
2. 反引号用来创建原生的字符串字面量，这些字符串可能由多行组成(不支持任何转义序列)，原生的字符串字面量多用于书写多行消息、HTML以及正则表达式
3. 单引号则用于表示Golang的一个特殊类型: rune，是指: 码点字面量(Unicode code point)，不做任何转义的原始内容。

##结构体嵌套
---
在嵌套结构体中，People 称为内部类型，Teacher称为外部类型；通过嵌套，内部类型的属性、方法，可以为外部类型所有，就好像是外部类型自己的一样。此外，外部类型还可以定义自己的属性和方法，甚至可以定义与内部相同的方法，这样内部类型的方法就会被“屏蔽”。这个例子中的 ShowB() 就是同名方法。
```go
type People struct{}

func (p *People) ShowA() {
    fmt.Println("showA")
    p.ShowB()
}
func (p *People) ShowB() {
    fmt.Println("showB")
}

type Teacher struct {
    People
}

func (t *Teacher) ShowB() {
    fmt.Println("teacher showB")
}
```