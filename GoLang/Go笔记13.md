## 内存对齐
---
> CPU 访问内存时，并不是逐个字节访问，而是以字长(word size)为单位访问。比如 32 位的 CPU ，字长为 4 字节，那么 CPU 访问内存的单位也是 4 字节。这么设计的目的，是减少 CPU 访问内存的次数，加大 CPU 访问内存的吞吐量。比如同样读取 8 个字节的数据，一次读取 4 个字节那么只需要读取 2 次。CPU 始终以字长访问内存，如果不进行内存对齐，很可能增加 CPU 访问内存的次数

1. 一个结构体实例所占据的空间等于各字段占据空间之和，再加上内存对齐的空间大小
2. 对于Struct来说，调整字段顺序可以减少内存占用
3. 当空struct作为结构体最后一个字段时会额外填充一段内存以防止内存泄漏，如果有这种情况可以和其他字段换顺序来减小内存


```go
unsafe.Alignof(Args{}) // 8
unsafe.Alignof(Flag{}) // 4
```

| 类型 | 字节大小 |
| :-----: | :----: |
| byte, unit8, int8 | 1 |
| unit16, int16 | 2 |
| unit32, int32, float32 | 4 |
| unit64, int64, float64, complex64 | 8 |
| complex128 | 16 |

对齐保证
1. 对于任意类型的变量 x ，`unsafe.Alignof(x)` 至少为 1。
2. 对于 struct 结构体类型的变量 x，计算 x 每一个字段 f 的 `unsafe.Alignof(x.f)`，`unsafe.Alignof(x)` 等于其中的最大值。
3. 对于 array 数组类型的变量 x，`unsafe.Alignof(x)` 等于构成数组的元素类型的对齐倍数。

## 逃逸分析
---
> 在函数中申请一个对象，如果分配在栈中，函数执行结束时自动回收，如果分配在堆中，则在函数结束后某个时间点进行垃圾回收。
在栈上分配和回收内存的开销很低，只需要 2 个 CPU 指令：PUSH 和 POP，一个是将数据 push 到栈空间以完成分配，pop 则是释放空间，在栈上分配内存效率是非常高的。在堆上分配内存，一个很大的额外开销则是垃圾回收。Go 语言使用的是标记清除算法，并且在此基础上使用了三色标记法和写屏障技术，提高了效率。
Go 编译器怎么知道某个变量需要分配在栈上，还是堆上呢？编译器决定内存分配位置的方式，就称之为逃逸分析(escape analysis)。逃逸分析由编译器完成，作用于编译阶段。

**指针逃逸**
在函数中创建了一个对象，返回了这个对象的指针。这种情况下，函数虽然退出了，但是因为指针的存在，对象的内存不能随着函数结束而回收，因此只能分配在堆上。

**空接口**
在 Go 语言中，空接口即 interface{} 可以表示任意的类型，如果函数参数为 interface{}，编译期间很难确定其参数的具体类型，也会发生逃逸。

**超过一定大小的对象**
操作系统对内核线程使用的栈空间是有大小限制的，64 位系统上通常是 8 MB。对 Go 编译器而言，超过一定大小的局部变量将逃逸到堆上。

**闭包**
一个函数和对其周围状态(lexical environment，词法环境)的引用捆绑在一起，这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。

```shell
// 查看机器上栈允许占用的内存的大小
ulimit -a

// 选项 -gcflags=-m查看变量逃逸的情况
go build -gcflags=-m main.go
```

1. 传值会拷贝整个对象，而传指针只会拷贝指针地址，指向的对象是同一个。传指针可以减少值的拷贝，但是会导致内存分配逃逸到堆中，增加垃圾回收(GC)的负担。在对象频繁创建和删除的场景下，传递指针导致的 GC 开销可能会严重影响性能。
2. 对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。对于只读的占用内存较小的结构体，直接传值能够获得更好的性能。

## sync锁
---
**互斥锁有两种状态: 正常状态和饥饿状态**
1. 正常状态: 所有等待锁的goroutine按照FIFO顺序等待。唤醒的goroutine不会直接拥有锁，而是会和新请求锁的goroutine竞争锁的拥有。新请求锁的goroutine具有优势：它正在CPU上执行，而且可能有好几个，所以刚刚唤醒的goroutine有很大可能在锁竞争中失败。在这种情况下，这个被唤醒的goroutine会加入到等待队列的前面。 如果一个等待的goroutine超过1ms没有获取锁，那么它将会把锁转变为饥饿模式。
2. 饥饿模式: 锁的所有权将从unlock的gorutine直接交给交给等待队列中的第一个。新来的goroutine将不会尝试去获得锁，即使锁看起来是unlock状态, 也不会去尝试自旋操作，而是放在等待队列的尾部。

如果一个等待的goroutine获取了锁，并且满足一以下其中的任何一个条件，它会将锁的状态转换为正常状态，正常状态有很好的性能表现，饥饿模式也是非常重要的，因为它能阻止尾部延迟的现象。
1. 它是队列中的最后一个
2. 它等待的时候小于1ms。它会将锁的状态转换为正常状态。

**自旋**
加锁时，如果当前Locked位为1，说明该锁当前由其他协程持有，尝试加锁的协程并不是马上转入阻塞，而是会持续的探测Locked位是否变为0，这个过程即为自旋过程。自旋时间很短，但如果在自旋过程中发现锁已被释放，那么协程可以立即获取锁。此时即便有协程被唤醒也无法获取锁，只能再次阻塞。自旋的好处是，当加锁失败时不必立即转入阻塞，有一定机会获取到锁，这样可以避免协程的切换。

## 死码消除
---
死码消除(dead code elimination, DCE)是一种编译器优化技术，用处是在编译阶段去掉对程序运行结果没有任何影响的代码，死码消除有很多好处: 减小程序体积，程序运行过程中避免执行无用的指令，缩短运行时间

go语言中在某些场景下，将变量替换为常量，可以提升性能
因此，在声明全局变量时，如果能够确定为常量，尽量使用 const 而非 var，这样很多运算在编译器即可执行。死码消除后，既减小了二进制的体积，又可以提高运行时的效率。